# 通知功能设计文档

## 1. 概述

通知功能用于向用户推送各种类型的系统通知，包括好友申请、群聊邀请、新消息提醒等。通知通过 WebSocket 实时推送，同时支持历史通知查询和已读/未读状态管理。

## 2. 通知类型

### 2.1 通知类型枚举

```go
// 通知类型
const (
    NotificationTypeFriendApply    = 1  // 好友申请
    NotificationTypeGroupInvite    = 2  // 群聊邀请
    NotificationTypeNewMessage     = 3  // 新消息（用户不在当前聊天窗口时）
    NotificationTypeSystem         = 4  // 系统通知
    NotificationTypeGroupApply     = 5  // 群聊申请（用户申请加入群聊）
    NotificationTypeContactAccepted = 6  // 好友申请已通过
    NotificationTypeContactRejected = 7  // 好友申请已拒绝
    NotificationTypeGroupAccepted   = 8  // 群聊申请已通过
    NotificationTypeGroupRejected  = 9  // 群聊申请已拒绝
)
```

### 2.2 通知状态枚举

```go
// 通知状态
const (
    NotificationStatusUnread = 0  // 未读
    NotificationStatusRead   = 1  // 已读
    NotificationStatusDeleted = 2 // 已删除（软删除）
)
```

## 3. 数据模型设计

### 3.1 Notification 模型

```go
type Notification struct {
    Id          int64          `gorm:"column:id;primaryKey;comment:自增id"`
    Uuid        string         `gorm:"column:uuid;uniqueIndex;type:char(20);not null;comment:通知uuid"`
    UserId      string         `gorm:"column:user_id;index;type:char(20);not null;comment:接收者用户id"`
    Type        int8           `gorm:"column:type;not null;comment:通知类型，1.好友申请，2.群聊邀请，3.新消息，4.系统通知，5.群聊申请，6.好友申请已通过，7.好友申请已拒绝，8.群聊申请已通过，9.群聊申请已拒绝"`
    Title       string         `gorm:"column:title;type:varchar(100);not null;comment:通知标题"`
    Content     string         `gorm:"column:content;type:TEXT;comment:通知内容"`
    RelatedId   string         `gorm:"column:related_id;index;type:char(20);comment:关联id（如申请id、消息id等）"`
    RelatedType string         `gorm:"column:related_type;type:varchar(20);comment:关联类型（如contact_apply、message等）"`
    SenderId    string         `gorm:"column:sender_id;index;type:char(20);comment:发送者id（如果是系统通知则为空）"`
    SenderName  string         `gorm:"column:sender_name;type:varchar(20);comment:发送者昵称"`
    SenderAvatar string        `gorm:"column:sender_avatar;type:varchar(255);comment:发送者头像"`
    Status      int8           `gorm:"column:status;not null;default:0;comment:通知状态，0.未读，1.已读，2.已删除"`
    ExtraData   string         `gorm:"column:extra_data;type:TEXT;comment:额外数据（JSON格式，用于存储扩展信息）"`
    CreatedAt   time.Time      `gorm:"column:created_at;not null;comment:创建时间"`
    ReadAt      sql.NullTime   `gorm:"column:read_at;comment:已读时间"`
    DeletedAt   gorm.DeletedAt `gorm:"column:deleted_at;index;type:timestamp;comment:删除时间"`
}
```

### 3.2 数据库表结构

```sql
CREATE TABLE `notification` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '自增id',
  `uuid` char(20) NOT NULL COMMENT '通知uuid',
  `user_id` char(20) NOT NULL COMMENT '接收者用户id',
  `type` tinyint NOT NULL COMMENT '通知类型，1.好友申请，2.群聊邀请，3.新消息，4.系统通知，5.群聊申请，6.好友申请已通过，7.好友申请已拒绝，8.群聊申请已通过，9.群聊申请已拒绝',
  `title` varchar(100) NOT NULL COMMENT '通知标题',
  `content` text COMMENT '通知内容',
  `related_id` char(20) DEFAULT NULL COMMENT '关联id（如申请id、消息id等）',
  `related_type` varchar(20) DEFAULT NULL COMMENT '关联类型（如contact_apply、message等）',
  `sender_id` char(20) DEFAULT NULL COMMENT '发送者id（如果是系统通知则为空）',
  `sender_name` varchar(20) DEFAULT NULL COMMENT '发送者昵称',
  `sender_avatar` varchar(255) DEFAULT NULL COMMENT '发送者头像',
  `status` tinyint NOT NULL DEFAULT '0' COMMENT '通知状态，0.未读，1.已读，2.已删除',
  `extra_data` text COMMENT '额外数据（JSON格式）',
  `created_at` timestamp NOT NULL COMMENT '创建时间',
  `read_at` timestamp NULL DEFAULT NULL COMMENT '已读时间',
  `deleted_at` timestamp NULL DEFAULT NULL COMMENT '删除时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uuid` (`uuid`),
  KEY `user_id` (`user_id`),
  KEY `related_id` (`related_id`),
  KEY `sender_id` (`sender_id`),
  KEY `deleted_at` (`deleted_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='通知表';
```

## 4. 后端接口设计

### 4.1 通知控制器 (NotificationController)

#### 4.1.1 获取通知列表

**接口**: `POST /notification/getNotificationList`

**请求参数**:
```go
type GetNotificationListRequest struct {
    UserId   string `json:"user_id" binding:"required"`   // 用户ID
    Page     int    `json:"page"`                         // 页码，从1开始
    PageSize int    `json:"page_size"`                   // 每页数量，默认20
    Type     *int8  `json:"type"`                        // 通知类型筛选（可选）
    Status   *int8  `json:"status"`                      // 状态筛选（可选，0.未读，1.已读）
}
```

**响应参数**:
```go
type GetNotificationListResponse struct {
    Code    int                      `json:"code"`
    Message string                   `json:"message"`
    Data    []NotificationListItem   `json:"data"`
    Total   int64                    `json:"total"`  // 总数量
}

type NotificationListItem struct {
    Uuid        string `json:"uuid"`
    Type        int8   `json:"type"`
    Title       string `json:"title"`
    Content     string `json:"content"`
    RelatedId   string `json:"related_id"`
    RelatedType string `json:"related_type"`
    SenderId    string `json:"sender_id"`
    SenderName  string `json:"sender_name"`
    SenderAvatar string `json:"sender_avatar"`
    Status      int8   `json:"status"`
    ExtraData   string `json:"extra_data"`
    CreatedAt   string `json:"created_at"`
    ReadAt      string `json:"read_at,omitempty"`
}
```

#### 4.1.2 获取未读通知数量

**接口**: `POST /notification/getUnreadCount`

**请求参数**:
```go
type GetUnreadCountRequest struct {
    UserId string `json:"user_id" binding:"required"`
    Type   *int8  `json:"type"`  // 通知类型筛选（可选）
}
```

**响应参数**:
```go
type GetUnreadCountResponse struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Data    struct {
        Count int64 `json:"count"`
    } `json:"data"`
}
```

#### 4.1.3 标记通知为已读

**接口**: `POST /notification/markAsRead`

**请求参数**:
```go
type MarkAsReadRequest struct {
    UserId         string   `json:"user_id" binding:"required"`
    NotificationIds []string `json:"notification_ids"`  // 通知ID列表，为空则标记所有未读为已读
}
```

**响应参数**:
```go
type MarkAsReadResponse struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Data    struct {
        Count int64 `json:"count"`  // 标记为已读的数量
    } `json:"data"`
}
```

#### 4.1.4 删除通知

**接口**: `POST /notification/deleteNotification`

**请求参数**:
```go
type DeleteNotificationRequest struct {
    UserId         string   `json:"user_id" binding:"required"`
    NotificationIds []string `json:"notification_ids" binding:"required"`
}
```

**响应参数**:
```go
type DeleteNotificationResponse struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Data    struct {
        Count int64 `json:"count"`  // 删除的数量
    } `json:"data"`
}
```

#### 4.1.5 清空所有通知

**接口**: `POST /notification/clearAll`

**请求参数**:
```go
type ClearAllNotificationRequest struct {
    UserId string `json:"user_id" binding:"required"`
    Type   *int8  `json:"type"`  // 通知类型筛选（可选），为空则清空所有类型
}
```

**响应参数**:
```go
type ClearAllNotificationResponse struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Data    struct {
        Count int64 `json:"count"`  // 清空的数量
    } `json:"data"`
}
```

### 4.2 通知服务 (NotificationService)

#### 4.2.1 创建通知

```go
// CreateNotification 创建通知
// message: 返回给前端的提示
// data: 返回的通知对象
// ret: 0.成功，-1.系统错误，-2.业务错误
func CreateNotification(userId string, notificationType int8, title string, content string, relatedId string, relatedType string, senderId string, senderName string, senderAvatar string, extraData string) (message string, data *model.Notification, ret int)
```

#### 4.2.2 获取通知列表

```go
// GetNotificationList 获取通知列表
func GetNotificationList(userId string, page int, pageSize int, notificationType *int8, status *int8) (message string, data []NotificationListItem, total int64, ret int)
```

#### 4.2.3 获取未读数量

```go
// GetUnreadCount 获取未读通知数量
func GetUnreadCount(userId string, notificationType *int8) (message string, count int64, ret int)
```

#### 4.2.4 标记为已读

```go
// MarkAsRead 标记通知为已读
func MarkAsRead(userId string, notificationIds []string) (message string, count int64, ret int)
```

#### 4.2.5 删除通知

```go
// DeleteNotification 删除通知（软删除）
func DeleteNotification(userId string, notificationIds []string) (message string, count int64, ret int)
```

#### 4.2.6 清空所有通知

```go
// ClearAllNotification 清空所有通知（软删除）
func ClearAllNotification(userId string, notificationType *int8) (message string, count int64, ret int)
```

## 5. WebSocket 推送机制

### 5.1 通知推送消息格式

当有新通知时，通过 WebSocket 向用户推送通知：

```go
type NotificationPushMessage struct {
    Type    string                 `json:"type"`    // 固定为 "notification"
    Data    NotificationListItem   `json:"data"`    // 通知数据
    UnreadCount int64              `json:"unread_count"`  // 当前未读数量
}
```

### 5.2 推送时机

1. **好友申请通知**: 当用户提交好友申请时，向被申请用户推送通知
2. **群聊邀请通知**: 当用户被邀请加入群聊时，推送通知
3. **新消息通知**: 当用户不在当前聊天窗口时，收到新消息时推送通知
4. **系统通知**: 系统主动推送的通知
5. **申请结果通知**: 当好友申请或群聊申请被处理时，向申请人推送结果通知

### 5.3 推送实现

在 `internal/service/chat/server.go` 和 `internal/service/chat/kafka_server.go` 中添加推送通知的方法：

```go
// PushNotification 推送通知给用户
func PushNotification(userId string, notification *model.Notification) {
    // 查询用户是否在线
    if client, ok := ChatServer.Clients[userId]; ok {
        // 构建推送消息
        notificationItem := NotificationListItem{
            Uuid:        notification.Uuid,
            Type:        notification.Type,
            Title:       notification.Title,
            Content:     notification.Content,
            RelatedId:   notification.RelatedId,
            RelatedType: notification.RelatedType,
            SenderId:    notification.SenderId,
            SenderName:  notification.SenderName,
            SenderAvatar: notification.SenderAvatar,
            Status:      notification.Status,
            ExtraData:   notification.ExtraData,
            CreatedAt:   notification.CreatedAt.Format("2006-01-02 15:04:05"),
        }
        
        // 获取未读数量
        _, unreadCount, _ := notificationService.GetUnreadCount(userId, nil)
        
        pushMessage := NotificationPushMessage{
            Type:        "notification",
            Data:        notificationItem,
            UnreadCount: unreadCount,
        }
        
        jsonMessage, err := json.Marshal(pushMessage)
        if err != nil {
            zlog.Error("序列化通知消息失败: " + err.Error())
            return
        }
        
        var messageBack = &MessageBack{
            Message: jsonMessage,
            Uuid:    notification.Uuid,
        }
        
        client.SendBack <- messageBack
    }
}
```

### 5.4 关于 Kafka 的使用

**结论：通知服务不需要使用 Kafka**

**原因分析：**

1. **通知的特点**：
   - 通知创建频率相对较低（相比聊天消息）
   - 通知需要立即推送给用户（实时性要求高）
   - 通知的创建和推送是同步的（创建后立即推送）
   - 通知不需要像聊天消息那样处理高并发写入

2. **Kafka 的适用场景**：
   - 高并发写入（如聊天消息）
   - 需要解耦生产者和消费者
   - 需要消息持久化和重试机制
   - 需要支持多个消费者（如消息推送、消息存储、消息分析等）

3. **通知服务的实际情况**：
   - 通知创建频率低，不需要高并发处理
   - 通知创建后需要立即推送，是同步操作
   - 通知的创建和推送是紧耦合的（创建后立即推送给特定用户）
   - 通知不需要多个消费者处理

4. **实现方式**：
   - **直接推送**：创建通知后，如果用户在线，直接通过 WebSocket 推送
   - **数据库持久化**：通知已存储在数据库中，用户离线时可以在登录后查询
   - **简单高效**：不需要额外的消息队列，减少系统复杂度

**如果未来需要 Kafka 的场景**：
- 通知量非常大（如百万级用户同时收到系统通知）
- 需要通知的异步处理和批量推送
- 需要通知的统计分析（需要多个消费者处理）
- 需要通知的重试机制（推送失败后重试）

**当前建议**：
- 使用直接推送方式，简单高效
- 如果用户不在线，通知已存储在数据库中，用户上线后可以查询
- 如果未来通知量激增，再考虑引入 Kafka 进行异步处理

## 6. 业务逻辑集成

### 6.1 好友申请流程

1. 用户A申请添加用户B为好友
2. 创建 `ContactApply` 记录
3. **创建通知**：向用户B推送好友申请通知
4. 用户B处理申请（通过/拒绝）
5. **创建通知**：向用户A推送申请结果通知

### 6.2 群聊邀请流程

1. 群主/管理员邀请用户加入群聊
2. **创建通知**：向被邀请用户推送群聊邀请通知
3. 用户处理邀请（接受/拒绝）

### 6.3 新消息流程

1. 用户A向用户B发送消息
2. **更新会话最后消息**：更新双向会话的 `last_message` 和 `last_message_at` 字段（详见6.5.5节）
3. **判断是否需要推送通知**：
   - 检查用户B是否在当前聊天窗口（通过前端状态）
   - 如果用户B不在当前聊天窗口，**创建通知**：向用户B推送新消息通知
   - 如果用户B在当前聊天窗口，不推送通知（避免重复提醒）
4. **统计未读消息数量**：基于会话的 `last_viewed_at` 字段统计未读数量（详见6.6节）

**注意**：双向会话在好友关系建立时已创建（详见6.5节），消息处理时无需再创建会话。

### 6.4 系统通知流程

1. 系统需要向用户推送通知时
2. 调用 `CreateNotification` 创建通知
3. 通过 WebSocket 推送通知

### 6.5 双向会话创建机制

#### 6.5.1 问题描述

当前系统采用单向会话设计：
- A向B发送消息时，创建会话 `send_id=A, receive_id=B`
- B的会话列表只查询 `send_id=B` 的会话
- 因此B看不到A->B的会话，无法得知A发送了消息

#### 6.5.2 解决方案：在建立好友关系时创建双向会话

**设计思路**：

在好友关系建立时（通过好友申请时），一次性创建双向会话，避免每次发消息都检查是否有反向会话。这样更优雅、性能更好。

**实现位置**：

在 `internal/service/gorm/user_contact_service.go` 的 `PassContactApply` 函数中，当好友申请通过时创建双向会话：

```go
// PassContactApply 通过联系人申请
func (u *userContactService) PassContactApply(ownerId string, contactId string) (string, int) {
    // ... 现有逻辑：更新申请状态、创建双向 UserContact ...
    
    if ownerId[0] == 'U' {
        // ... 现有逻辑 ...
        
        // 创建双向 UserContact 后，创建双向会话
        // 1. 为 ownerId 创建会话：ownerId -> contactId
        createSessionReq1 := request.CreateSessionRequest{
            SendId:    ownerId,
            ReceiveId: contactId,
        }
        _, sessionId1, ret1 := SessionService.CreateSession(createSessionReq1)
        if ret1 != 0 {
            zlog.Warn(fmt.Sprintf("创建会话失败: %s->%s", ownerId, contactId))
        }
        
        // 2. 为 contactId 创建会话：contactId -> ownerId
        createSessionReq2 := request.CreateSessionRequest{
            SendId:    contactId,
            ReceiveId: ownerId,
        }
        _, sessionId2, ret2 := SessionService.CreateSession(createSessionReq2)
        if ret2 != 0 {
            zlog.Warn(fmt.Sprintf("创建会话失败: %s->%s", contactId, ownerId))
        }
        
        // 清除双方的会话列表缓存
        myredis.DelKeysWithPattern("session_list_" + ownerId)
        myredis.DelKeysWithPattern("session_list_" + contactId)
        
        // 如果创建会话失败，通过通知系统告知用户（方案三）
        if ret1 != 0 || ret2 != 0 {
            // 通知双方会话创建失败
            if ret1 != 0 {
                CreateNotification(
                    ownerId,
                    NotificationTypeSystem,
                    "系统通知",
                    fmt.Sprintf("与 %s 的会话创建失败，请手动创建会话", contactName),
                    "",
                    "system",
                    "",
                    "",
                    "",
                    fmt.Sprintf(`{"contact_id": "%s", "need_create_session": true}`, contactId),
                )
            }
            if ret2 != 0 {
                CreateNotification(
                    contactId,
                    NotificationTypeSystem,
                    "系统通知",
                    fmt.Sprintf("与 %s 的会话创建失败，请手动创建会话", ownerName),
                    "",
                    "system",
                    "",
                    "",
                    "",
                    fmt.Sprintf(`{"contact_id": "%s", "need_create_session": true}`, ownerId),
                )
            }
        }
        
        return "已添加该联系人", 0
    }
    // ... 群聊逻辑 ...
}
```

**优点**：
- **性能更好**：只在好友关系建立时创建一次，不需要每次发消息都检查
- **逻辑更清晰**：好友关系建立时就准备好会话，符合业务逻辑
- **代码更优雅**：避免在消息处理逻辑中频繁检查数据库
- **用户体验好**：好友关系建立后，双方都能立即看到对方的会话

**注意事项**：
- 需要检查会话是否已存在，避免重复创建
- 如果创建会话失败，需要通过通知系统告知用户
- 需要清除双方的会话列表缓存

#### 6.5.3 检查会话是否已存在

在创建会话前，先检查是否已存在：

```go
// 检查 ownerId -> contactId 的会话是否已存在
var existingSession1 model.Session
if err := dao.GormDB.Where("send_id = ? AND receive_id = ?", 
    ownerId, contactId).First(&existingSession1).Error; err != nil {
    if errors.Is(err, gorm.ErrRecordNotFound) {
        // 会话不存在，创建新会话
        _, _, ret1 := SessionService.CreateSession(createSessionReq1)
        // ... 处理结果 ...
    }
} else {
    // 会话已存在，跳过创建
    zlog.Info(fmt.Sprintf("会话已存在: %s->%s, session_id=%s", 
        ownerId, contactId, existingSession1.Uuid))
}

// 检查 contactId -> ownerId 的会话是否已存在
var existingSession2 model.Session
if err := dao.GormDB.Where("send_id = ? AND receive_id = ?", 
    contactId, ownerId).First(&existingSession2).Error; err != nil {
    if errors.Is(err, gorm.ErrRecordNotFound) {
        // 会话不存在，创建新会话
        _, _, ret2 := SessionService.CreateSession(createSessionReq2)
        // ... 处理结果 ...
    }
} else {
    // 会话已存在，跳过创建
    zlog.Info(fmt.Sprintf("会话已存在: %s->%s, session_id=%s", 
        contactId, ownerId, existingSession2.Uuid))
}
```

#### 6.5.4 补充方案：通知系统

如果创建会话失败（如数据库错误、用户被禁用等），通过通知系统告知用户：

```go
if ret1 != 0 || ret2 != 0 {
    // 创建会话失败，发送通知
    if ret1 != 0 {
        CreateNotification(
            ownerId,
            NotificationTypeSystem,
            "系统通知",
            fmt.Sprintf("与 %s 的会话创建失败，请手动创建会话", contactName),
            "",
            "system",
            "",
            "",
            "",
            fmt.Sprintf(`{"contact_id": "%s", "need_create_session": true}`, contactId),
        )
    }
    if ret2 != 0 {
        CreateNotification(
            contactId,
            NotificationTypeSystem,
            "系统通知",
            fmt.Sprintf("与 %s 的会话创建失败，请手动创建会话", ownerName),
            "",
            "system",
            "",
            "",
            "",
            fmt.Sprintf(`{"contact_id": "%s", "need_create_session": true}`, ownerId),
        )
    }
}
```

这样即使创建会话失败，用户也能通过通知得知，并可以手动创建会话。

#### 6.5.5 消息处理逻辑简化

由于在好友关系建立时已经创建了双向会话，消息处理逻辑中不再需要检查并创建反向会话，只需要更新会话的最后消息即可：

```go
// 在消息处理逻辑中（server.go 和 kafka_server.go）
if message.ReceiveId[0] == 'U' { // 发送给User
    // ... 现有消息处理逻辑 ...
    
    // 更新会话的最后消息（双向都更新）
    // 1. 更新发送者的会话
    dao.GormDB.Model(&model.Session{}).
        Where("send_id = ? AND receive_id = ?", message.SendId, message.ReceiveId).
        Updates(map[string]interface{}{
            "last_message":   message.Content,
            "last_message_at": time.Now(),
        })
    
    // 2. 更新接收者的会话（如果存在）
    dao.GormDB.Model(&model.Session{}).
        Where("send_id = ? AND receive_id = ?", message.ReceiveId, message.SendId).
        Updates(map[string]interface{}{
            "last_message":   message.Content,
            "last_message_at": time.Now(),
        })
    
    // ... 继续现有逻辑 ...
}
```

### 6.6 新消息数量统计方案

#### 6.6.1 方案选择：方案一（最后查看时间）+ 方案三（前端状态）

**方案一：基于会话最后查看时间**

在 `Session` 表中添加 `last_viewed_at` 字段，记录用户最后查看该会话的时间。

**方案三：基于前端状态**

前端告诉后端用户当前在哪个聊天窗口，用于判断是否推送通知。

#### 6.6.2 数据库设计

**修改 Session 模型**：

```go
type Session struct {
    // ... 现有字段
    LastViewedAt sql.NullTime `gorm:"column:last_viewed_at;type:timestamp;comment:用户最后查看该会话的时间"`
}
```

**数据库迁移**：

```sql
-- 在 Session 表中添加 last_viewed_at 字段
ALTER TABLE session ADD COLUMN last_viewed_at TIMESTAMP NULL COMMENT '用户最后查看该会话的时间';

-- 为每个用户创建索引
CREATE INDEX idx_session_send_viewed ON session(send_id, last_viewed_at);
CREATE INDEX idx_session_receive_viewed ON session(receive_id, last_viewed_at);
```

#### 6.6.3 统计未读消息数量

**单个会话的未读数量**：

```go
// GetUnreadMessageCount 获取会话的未读消息数量
func GetUnreadMessageCount(userId string, sessionId string) (int64, error) {
    // 1. 查询会话的最后查看时间
    var session model.Session
    if err := dao.GormDB.Where("uuid = ? AND (send_id = ? OR receive_id = ?)", 
        sessionId, userId, userId).First(&session).Error; err != nil {
        return 0, err
    }
    
    // 2. 查询在最后查看时间之后的消息数量
    var count int64
    query := dao.GormDB.Model(&model.Message{}).
        Where("session_id = ? AND receive_id = ?", sessionId, userId)
    
    if session.LastViewedAt.Valid {
        query = query.Where("created_at > ?", session.LastViewedAt.Time)
    } else {
        // 如果从未查看过，统计所有消息
        // count 已经初始化为0，查询所有消息
    }
    
    query.Count(&count)
    return count, nil
}
```

**所有会话的未读消息总数**：

```go
// GetTotalUnreadMessageCount 获取用户所有会话的未读消息总数
func GetTotalUnreadMessageCount(userId string) (int64, error) {
    var totalCount int64
    
    // 查询用户的所有会话（作为发送者和接收者）
    var sessions []model.Session
    dao.GormDB.Where("(send_id = ? OR receive_id = ?) AND deleted_at IS NULL", 
        userId, userId).Find(&sessions)
    
    // 统计每个会话的未读消息
    for _, session := range sessions {
        var sessionCount int64
        query := dao.GormDB.Model(&model.Message{}).
            Where("session_id = ? AND receive_id = ?", session.Uuid, userId)
        
        if session.LastViewedAt.Valid {
            query = query.Where("created_at > ?", session.LastViewedAt.Time)
        }
        
        query.Count(&sessionCount)
        totalCount += sessionCount
    }
    
    return totalCount, nil
}
```

#### 6.6.4 更新最后查看时间

**用户打开聊天窗口时**：

```go
// UpdateLastViewedAt 更新用户最后查看会话的时间
func UpdateLastViewedAt(userId string, sessionId string) error {
    return dao.GormDB.Model(&model.Session{}).
        Where("uuid = ? AND (send_id = ? OR receive_id = ?)", 
            sessionId, userId, userId).
        Update("last_viewed_at", time.Now()).Error
}
```

**调用时机**：
- 用户打开聊天窗口时（前端调用接口）
- 用户切换到其他聊天窗口时
- 用户查看消息列表时

#### 6.6.5 判断是否推送通知（方案三：前端状态）

**前端传递当前聊天窗口信息**：

```javascript
// 前端在打开聊天窗口时，告诉后端当前聊天窗口
socket.send(JSON.stringify({
    type: 'update_current_chat',
    current_session_id: sessionId,
    user_id: userId
}))
```

**后端判断是否需要推送通知**：

```go
// 在推送消息时判断
func ShouldPushNotification(receiveId string, sessionId string) bool {
    // 检查用户是否在当前聊天窗口
    // 可以通过 Redis 存储用户的当前聊天窗口状态
    currentSessionId := getUserCurrentSession(receiveId)
    return currentSessionId != sessionId
}

// 在创建新消息通知时使用
func CreateNewMessageNotification(receiveId string, sessionId string, messageId string, sendId string, sendName string, sendAvatar string) {
    // 检查用户是否在当前聊天窗口
    if !ShouldPushNotification(receiveId, sessionId) {
        // 用户在当前聊天窗口，不推送通知
        return
    }
    
    // 统计该会话的未读消息数量
    unreadCount, _ := GetUnreadMessageCount(receiveId, sessionId)
    
    // 创建通知
    CreateNotification(
        receiveId,
        NotificationTypeNewMessage,
        "新消息",
        fmt.Sprintf("您有 %d 条未读消息", unreadCount),
        messageId,
        "message",
        sendId,
        sendName,
        sendAvatar,
        fmt.Sprintf(`{"session_id": "%s", "unread_count": %d}`, sessionId, unreadCount),
    )
}
```

**存储用户当前聊天窗口状态**：

```go
// 在 Redis 中存储用户的当前聊天窗口
func SetUserCurrentSession(userId string, sessionId string) error {
    return myredis.SetKeyEx("user_current_session_"+userId, sessionId, time.Hour*24)
}

// 获取用户的当前聊天窗口
func GetUserCurrentSession(userId string) (string, error) {
    return myredis.GetKey("user_current_session_" + userId)
}
```

#### 6.6.6 在通知服务中使用

**创建新消息通知时统计未读数量**：

```go
// 在消息处理逻辑中
if message.ReceiveId[0] == 'U' {
    // ... 消息处理逻辑 ...
    
    // 判断是否需要推送通知
    if ShouldPushNotification(message.ReceiveId, message.SessionId) {
        // 统计未读数量
        unreadCount, _ := GetUnreadMessageCount(message.ReceiveId, message.SessionId)
        
        // 创建通知
        CreateNewMessageNotification(
            message.ReceiveId,
            message.SessionId,
            message.Uuid,
            message.SendId,
            message.SendName,
            message.SendAvatar,
        )
    }
}
```

#### 6.6.7 方案优势

**方案一（最后查看时间）的优势**：
- 性能好：只需要查询时间字段，不需要为每条消息标记已读状态
- 实现简单：只需要一个时间字段
- 统计准确：基于时间判断，逻辑清晰

**方案三（前端状态）的优势**：
- 避免重复提醒：用户在当前聊天窗口时不推送通知
- 用户体验好：不会打扰正在聊天的用户
- 实时性好：前端状态实时更新

**组合使用的优势**：
- 方案一用于统计未读数量，性能好
- 方案三用于判断是否推送通知，避免重复提醒
- 两者结合，既准确又高效

## 7. 前端交互设计

### 7.1 通知组件

#### 7.1.1 通知列表组件 (NotificationList.vue)

- 显示通知列表
- 支持按类型筛选
- 支持标记已读/删除
- 显示未读数量角标

#### 7.1.2 通知项组件 (NotificationItem.vue)

- 显示通知标题、内容、时间
- 显示发送者头像和昵称
- 支持点击跳转到相关页面
- 支持标记已读/删除操作

### 7.2 前端状态管理

在 Vuex store 中添加通知相关状态：

```javascript
state: {
    notifications: [],           // 通知列表
    unreadCount: 0,              // 未读数量
    currentNotificationType: null, // 当前筛选的通知类型
}

mutations: {
    SET_NOTIFICATIONS(state, notifications) {
        state.notifications = notifications
    },
    SET_UNREAD_COUNT(state, count) {
        state.unreadCount = count
    },
    ADD_NOTIFICATION(state, notification) {
        state.notifications.unshift(notification)
        state.unreadCount++
    },
    MARK_NOTIFICATION_READ(state, notificationIds) {
        // 更新通知状态
    },
    DELETE_NOTIFICATION(state, notificationIds) {
        // 删除通知
    },
}
```

### 7.3 WebSocket 消息处理

在 WebSocket 消息处理中添加通知消息的处理：

```javascript
socket.onmessage = (event) => {
    const message = JSON.parse(event.data)
    
    if (message.type === 'notification') {
        // 处理通知推送
        store.commit('ADD_NOTIFICATION', message.data)
        store.commit('SET_UNREAD_COUNT', message.unread_count)
        
        // 显示浏览器通知（如果用户允许）
        if (Notification.permission === 'granted') {
            new Notification(message.data.title, {
                body: message.data.content,
                icon: message.data.sender_avatar || defaultAvatar,
            })
        }
    } else {
        // 处理其他消息类型
    }
}
```

### 7.4 前端 API 调用

创建通知相关的 API 调用函数：

```javascript
// api/notification.js
export const getNotificationList = (params) => {
    return axios.post('/notification/getNotificationList', params)
}

export const getUnreadCount = (params) => {
    return axios.post('/notification/getUnreadCount', params)
}

export const markAsRead = (params) => {
    return axios.post('/notification/markAsRead', params)
}

export const deleteNotification = (params) => {
    return axios.post('/notification/deleteNotification', params)
}

export const clearAllNotification = (params) => {
    return axios.post('/notification/clearAll', params)
}
```

## 8. 实现步骤

### 8.1 第一阶段：基础功能

1. 创建 Notification 模型和数据库表
2. 实现 NotificationService 基础方法
3. 实现 NotificationController 接口
4. 创建数据库迁移文件

### 8.2 第二阶段：WebSocket 推送

1. 在 chat server 中添加推送通知的方法
2. 在好友申请流程中集成通知创建和推送
3. 在群聊邀请流程中集成通知创建和推送

### 8.3 第三阶段：前端实现

1. 创建通知列表组件
2. 创建通知项组件
3. 在 Vuex 中添加通知状态管理
4. 实现 WebSocket 通知消息处理
5. 实现浏览器通知（需要用户授权）

### 8.4 第四阶段：新消息通知

1. 实现新消息通知逻辑（判断用户是否在当前聊天窗口）
2. 前端传递当前聊天窗口信息给后端
3. 后端根据用户状态决定是否推送通知

### 8.5 第五阶段：优化和测试

1. 性能优化（批量操作、分页加载）
2. 通知去重（避免重复通知）
3. 通知过期机制（自动清理旧通知）
4. 完整测试

## 9. 注意事项

1. **通知去重**: 避免同一事件创建多个重复通知
2. **性能优化**: 大量通知时使用分页加载，避免一次性加载所有通知
3. **浏览器通知**: 需要用户授权，需要处理权限被拒绝的情况
4. **通知过期**: 考虑实现通知自动过期机制，清理过期的旧通知
5. **并发安全**: WebSocket 推送时注意并发安全
6. **数据一致性**: 确保通知状态与业务数据的一致性（如好友申请状态与通知状态）

## 10. 扩展功能（可选）

1. **通知分类**: 支持用户自定义通知分类和筛选规则
2. **通知模板**: 支持不同类型的通知使用不同的显示模板
3. **通知优先级**: 支持设置通知优先级，重要通知优先显示
4. **通知聚合**: 将同一类型的多个通知聚合显示（如"您有3条新消息"）
5. **通知统计**: 提供通知统计功能，如每日通知数量、类型分布等

